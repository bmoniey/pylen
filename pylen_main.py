from PyQt5 import QtCore, QtGui, QtWidgets
from pylen_ui import Ui_MainWindow
from pylen import Pylen
import matplotlib.pyplot as plt
import numpy as np
import os
import traceback, sys


class WorkerSignals(QtCore.QObject):
    '''
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        tuple (exctype, value, traceback.format_exc() )

    result
        object data returned from processing, anything

    progress
        int indicating % progress

    '''
    finished = QtCore.pyqtSignal()
    error = QtCore.pyqtSignal(tuple)
    result = QtCore.pyqtSignal(object)
    progress = QtCore.pyqtSignal(int)

class Worker(QtCore.QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    '''

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

        # Add the callback to our kwargs
        self.kwargs['progress_callback'] = self.signals.progress

    @QtCore.pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''

        # Retrieve args/kwargs here; and fire processing using them
        try:
            result = self.fn(*self.args, **self.kwargs)
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done

class Pylen_UI(Ui_MainWindow):
    """
    Main UI window
    UI Generated using QT Designer
        UI_MainWindow derived from pylen_ui.ui
        pylen_ui.ui is generated by QTDesiger application
        to generate pylen_ui.py execute from terminal:
        >pyuic5 -xo pylen_ui.py pylen_ui.ui
    """
    def __init__(self):
        super().__init__()
        self.filename_report = None
        self.filename_gcode  = None
        self.pl = None
        self.threadpool = QtCore.QThreadPool()
        self.parse_completed = False
        self.parse_in_progress = False

    def pylen_setupUi(self, MainWindow):
        self.MainWindow = MainWindow
        self.setupUi(MainWindow)
        self.pushButton_Generate.clicked.connect(self.pushButtonGenerateClicked)
        self.pushButton_OpenReport.clicked.connect(self.pushButtonOpenReporteClicked)
        self.actionOpen.triggered.connect(self.actionFileOpenTrigger)
        self.actionHelp.triggered.connect(self.actionFileHelpTrigger)
        self.actionAbout.triggered.connect(self.actionFileAboutTrigger)
        self.textBrowser_OutputWindow.setText('Use File->Open to select GCode and then Click Generate Button.')
        self.progressBar.setProperty("value", 0)

    def pushButtonOpenReporteClicked(self):
        if self.filename_report is not None and os.path.exists(self.filename_report) is True:
            os.system(self.filename_report)
        else:
            msgBox = QtWidgets.QMessageBox()
            msgBoxTxt = """
                                <html><head/>
                                <body>
                                <p>No report exists</p>
                                </body>
                                </html>
                                """
            msgBox.setWindowTitle("Generate Message No GCode File Set")
            msgBox.setText(msgBoxTxt)
            msgBox.exec_()

    def actionFileOpenTrigger(self):
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(self.MainWindow, "QFileDialog.getOpenFileName()", "",
                                                  "GCode Files (*.gcode);;All Files (*)", options=options)
        if fileName:
            basename = os.path.basename(fileName)
            dirname  = os.path.dirname(fileName)
            basename_ = basename.split('.')
            self.filename_gcode = os.path.join(dirname, basename)
            self.filename_report = os.path.join(dirname, f"{basename_[0]}.csv")
            self.lineEdit_GCodePath.setText(self.filename_gcode)
            self.lineEdit_ReportPath.setText(self.filename_report)
            self.parse_completed = False
            self.progressBar.setProperty("value", 0)


    def actionFileHelpTrigger(self):
        msgBox = QtWidgets.QMessageBox()
        msgBoxTxt = """
        <html><head/>
        <body><p>Pylen Help:</p>
        <p>Program Purpose:</p>
        <p>Read 3DPrinter Gcode and extract filament usage per layer.
        The filamanent usage is the cumulative filament used at the &quot;END&quot; of each layer.
        </p>
        <p/>Uses:
        <p/>-Estimate filament used per layer
        <p/>-Plan layer color usage for multi color printing
        <p>File-&gt;Open</p>
        <p>Sets the path to the gcode file to be read. The default behavior is to set the report output path as the gcode_file.csv</p>
        <p>Report File Path</p><p>The path where pylen generates its report information as a .csv format which can be opened in a spreadsheet program</p><p>Generate:</p>
        <p>After the gcode path has been set using the File-&gt;Open action. Click on the Generate Button to create a usage report and display a usage graph</p>
        <p>Notes:</p>
        <p>Tested using Cura withe Ender 3 profile / Marlin flavor gcode!</p>
        <p>Send sample gcode for your printer to b.moniey@gmail.com to help add new flavors</p>
        </body></html>
        """
        msgBox.setWindowTitle("Pylen Help Window")
        msgBox.setText(msgBoxTxt)
        msgBox.exec_()


    def actionFileAboutTrigger(self):
        msgBox = QtWidgets.QMessageBox()
        msgBoxTxt = """
        <html><head/>
        <body>
        <p>Pylen Filament Usage Generator:</p>
        <p>Version:1.0.0</p>
        <p>Written by: Brian Moran</p>
        <p>Email:b.moniey@gmail.com</p>
        </body>
        </html>
        """
        msgBox.setWindowTitle("Pylen About Window")
        msgBox.setText(msgBoxTxt)
        msgBox.exec_()

    def makePlot(self):
        l = np.arange(1, int(self.pl.gc.d["LAYER_COUNT"])+1, 1)
        fig, ax = plt.subplots()
        ax.plot(l, self.pl.gc.edata, 'ro')
        plt.grid(True)
        ax.set(xlabel='Layer',
               ylabel='Filament Length Usage[mm]',
               title=f'file:{self.filename_gcode}')

        for n in l:
            label = f'({n},{self.pl.gc.edata[n-1]:.0f})'
            plt.annotate(label,
                         (n, self.pl.gc.edata[n-1]),
                         textcoords="offset points",
                         xytext=(30, -10),
                         ha='center')

        plt.show()

    def makeCSV(self):
        csv = [f'Start up Filament Usage[mm]:{self.pl.gc.start_eabs:.2f}']
        csv.append('N,length[mm]')
        for n in range(int(self.pl.gc.d["LAYER_COUNT"])):
            csv.append(f'{n + 1},{self.pl.gc.edata[n]:.0f}')
        return csv

    def makeCSVFile(self):
        fd = open(self.filename_report,'w')
        fd.write(f'gcode file:,{self.filename_gcode}\n')
        fd.write(f'Layer Count:,{self.pl.gc.d["LAYER_COUNT"]}\n')
        fd.write(f'Total Filament[mm]:,{float( self.pl.gc.d["Filament used"] ) * 1000.0:.1f}\n')
        fd.write(f'GCode Flavor:,{self.pl.gc.d["FLAVOR"]}\n')
        fd.write(f'Start up Filament Usage[mm],{self.pl.gc.start_eabs:.2f}\n')
        fd.write('Layer[-],length[mm]\n')
        for n in range(int(self.pl.gc.d["LAYER_COUNT"])):
            fd.write(f'{n + 1},{self.pl.gc.edata[n]:.0f}\n')
        fd.close()

    def update_progress(self):
        prog = self.pl.gc.progress()
        self.progressBar.setProperty("value", prog)

    def thread_complete(self):
        self.parse_completed = True

    def pushButtonGenerateClicked(self):
        if self.filename_gcode is not None and self.parse_in_progress is False:
            self.textBrowser_OutputWindow.setText('File Open, Starting a new session. Waiting for Generate to Start:')
            self.textBrowser_OutputWindow.append(f'GCode File Path Set to:{self.filename_gcode}')
            self.textBrowser_OutputWindow.append(f'GCode Report Path Set to:{self.filename_gcode}')
            self.textBrowser_OutputWindow.append('Reading GCode. This may take a moment...')
            #move the parsing to a worker thread

            self.pl = Pylen(self.filename_gcode)
           #self.pl.gc.parse()
            self.parse_completed = False
            self.parse_in_progress = True
            worker = Worker(self.pl.gc.parse)  # Any other args, kwargs are passed to the run function
            #worker.signals.result.connect(self.print_output)
            worker.signals.finished.connect(self.thread_complete)
            worker.signals.progress.connect(self.update_progress)

            # Execute
            self.threadpool.start(worker)
            while self.parse_completed is False:
                QtGui.QGuiApplication.processEvents()

            self.textBrowser_OutputWindow.append('Finished reading GCode')
            self.textBrowser_OutputWindow.append(f'total filament used:{self.pl.gc.eabs:.1f}[mm]')
            delta = float(self.pl.gc.d["Filament used"]) * 1000 -self.pl.gc.eabs
            if delta < 1:
                self.textBrowser_OutputWindow.append('Stated vs Calculated filament usage: < 1mm')
            else:
                self.textBrowser_OutputWindow.append(f'Stated vs Calculated filament usage:{delta:.1f}')
            self.textBrowser_OutputWindow.append(f'layer report for file:{self.filename_gcode}')
            self.textBrowser_OutputWindow.append(f'layer count:{int(self.pl.gc.d["LAYER_COUNT"])}')
            #csv = self.makeCSV()
            #for line in csv:
            #    self.textBrowser_OutputWindow.append(line)
            self.textBrowser_OutputWindow.append(f'generating csv file:{self.filename_report}')
            self.makeCSVFile()

            self.textBrowser_OutputWindow.append(f'generating plot')
            self.makePlot()
            self.textBrowser_OutputWindow.append(f'Done')
            self.parse_in_progress = False
        else:
            msgBox = QtWidgets.QMessageBox()
            msgBoxTxt = """
                    <html><head/>
                    <body>
                    <p>Use File Open to select GCode path or type in manually</p>
                    </body>
                    </html>
                    """
            msgBox.setWindowTitle("Generate Message No GCode File Set")
            msgBox.setText(msgBoxTxt)
            msgBox.exec_()

def main():
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Pylen_UI()
    ui.pylen_setupUi(MainWindow)
    MainWindow.show()

    sys.exit(app.exec_())

if __name__ == "__main__":
    main()